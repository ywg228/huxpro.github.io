---
layout:     post
title:      JavaScript变量作用域、作用域链和闭包
subtitle:   学习笔记 
date:       2017-07-11
author:     Ywg
header-img: img/home-bg.jpg
catalog:    true
tags: JavaScript JS深入
---

## 作用域
定义：只会对某个范围产生作用，而不会对外产生影响的封闭空间。在这样的一些空间里，外部不能访问内部变量，但内部可以访问外部变量。这就是作用域。<br>
在ES5中，js只有两种作用域：全局作用域和函数作用域 没有块级作用域！！<br>
块级作用域：任何一对花括号（｛和｝）中的if for while等语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，这就是块级作用域。 <br>
在ES6中，新增了一个块级作用域（最近的大括号涵盖的范围），但是仅限于let声明的变量。<br>
### 要点
#### 1. 作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的
![](http://images.cnitblog.com/blog/138012/201409/241708372951952.png)

全局代码和fn、bar两个函数都会形成一个作用域，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。
#### 2. 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突
看jQuery源码：<br>
![](http://images.cnitblog.com/blog/138012/201409/241709349512366.png)

jQuery源码的最外层是一个自动执行的匿名函数：为什么这样做呢？ <br>
原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。

#### 3. 作用域在函数定义时就已经确定了，而不是在函数调用时确定，作用域中变量的值是在执行过程中确定的

#### 4. 如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。
第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。

![](http://images.cnitblog.com/blog/138012/201409/250814158269779.png)

第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。

![](http://images.cnitblog.com/blog/138012/201409/250814386853995.png)

第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。

![](http://images.cnitblog.com/blog/138012/201409/250815006238997.png)

第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。

![](http://images.cnitblog.com/blog/138012/201409/250815248579200.png)

第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。

![](http://images.cnitblog.com/blog/138012/201409/250815435609914.png)

第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。

![](http://images.cnitblog.com/blog/138012/201409/250816112012394.png)

### 函数体内部，局部变量的优先级高于同名的全局变量
``` 
var a = 10    //定义全局变量 
function fn(){
  var a = 20;    //定义局部变量
  console.log(a);
}
fn(); //20
console.log(a); //10
``` 
### 变量声明提前数内声明的变量在函数体内始终是可见的
```
var a =10；
function fn() {
    console.log(scope);
    var a = 20;
}
fn(); //undefined
```
输出是undefined，并没有报错，这是因为变量声明提前以及局部变量的优先级高于同名的全局变量 <br>
上面的代码等效于：
```
var a = 10;
function fn() {
    var a;
    console.log(a);
    a = 20;
}
fn(); //undefined
```

### 未使用var关键字定义的变量都是全局变量。
如果变量如果不加var，那么变量就被声明为全局变量，自动加入到全局作用域中。
```
function fn() {
    a = 100;  
}
fn();
console.log(a); //100
```

### 全局变量都是window对象的属性
```
var a = 100 ;
console.log(window.a); //100
```

### ES5中没有块级作用域
``` 
var a = 10;
if(a > 5) { //true
  var b = 20;
}
console.log(b); //20
``` 
```
for (var i = 0; i < 10; i++) {
}
console.log(i); //10
```
所以不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义
```
var i；
for (i = 0; i < 10; i++) {
}
console.log(i); //10
```
很多时候我们会使用**匿名函数自执行来模拟块级作用域**，这样内部的变量就不会与外部的变量发生冲突了，常用于开发组件
```
(function() {
  //这里就是块级作用域
})();
```
### ES6中的块级作用域
但作用域限定在块级，let声明的变量不存在变量声明提升。<br>
ES6规定，如果代码块中存在let变量，这个区块从一开始就形成了封闭作用域。凡是在声明之前就使用，就会报错。即在代码块内，在let声明之前使用变量都是不可用的。
```
if(true) {
  let b = 20;
}
console.log(b); //访问不到，报错
```
```
for (let i = 0; i < 10; i++) {
    
}
console.log(i); //访问不到，报错
```
```
//let声明的变量不存在变量声明提升
function fn() {
    console.log(a) //a先使用后声明，报语法错
    let a;
}
```
#### 1. 不能重复声明
```
// 两个let重复声明
let age = 24;
let age = 30; //执行时会报错
```
#### 2. 有了let后，匿名函数自执行就可以去掉了
```
// 匿名函数写法
(function () {
  var fn = function() {};
  // ...
  window.fn = fn;
})();
// 块级作用域写法
{
  let fn = function() {};
  // ...
  window.fn = fn;
}
```
### 为什么需要块级作用域？
没有块级作用域，会带来很多不合理的场景：
#### 1. 第一种场景：内层变量可能会覆盖外层变量.
```
var tmp = new Date();
function f() {
  console.log(tmp); 
  if (false) {
    var tmp = 'hello world';
  }
}
f(); // undefined
```
由于变量声明提升，导致内层的tmp变量覆盖了外层的tmp变量。
#### 2. 第二种场景：用来计数的循环变量泄露为全局变量
```
var s = 'hello';
for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}
console.log(i); // 5
```
变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

## 自由变量
在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。<br>
如下代码:
```
var a = 10;
function fn() {
  var b = 20;
  console.log(a+b); //这里的a就是一个自由变量
}
```
**自由变量要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”**，无论这个函数将在哪里调用。这就是“静态作用域”。

## 作用域链
在javascript中，每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。 <br>
作用域链的前端是当前代码执行环境的变量对象，常被称之为“活跃对象”，变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中。 <br>
作用域链的逐级查找，也会影响到程序的性能，变量作用域链越长对性能影响越大，这也是我们尽量避免使用全局变量的一个主要原因。
```
var outVariable = "我是最外层变量"; //最外层变量
function outFun() { //最外层函数
    var inVariable = "内层变量";
    function innerFun() { //内层函数
        console.log(inVariable); //自由变量
        var tempVariable = inVariable;
    }
    innerFun();
}
```
其作用域链为：
```
window
├──outVariable
└──outFun()
   ├──inVariable
   └──innerFun()
      └──tempVariable
```
对于 innerFun()，其作用域链包含 3 个对象：innerFun() 自己的变量对象、outFun()的变量对象、全局变量对象。

## 闭包
闭包是指在当前作用域内总是能访问外部作用域中的变量。<br>
产生闭包的根本原因是作用域链
### 两种使用场景
#### 1. 函数作为返回值
```
function Fn(){
  var a = 10;
  return function() {
    console.log(a);
  }
}
var fn = new Fn();
var a = 20;
fn(); //10
```
#### 2. 函数作为参数传递
```
function Fn1(){
  var a = 10;
  return function() {
    console.log(a);
  }
}
var fn1 = new Fn1();
function Fn2(fn){
  var a = 20;
  fn();
}
Fn2(fn1); //10
```
### 实际应用
#### 封装变量
```
function isFirstLoad() {
  //在isFirstLoad外部，根本不可能修改_list的值
  var _list = [];
  return function (id) {
    if (_list.indexOf(id) >= 0) {
      return false;
    } else {
      _list.push(id);
      return false;
    }
  }
}
var firstLoad = isFirstLoad();
console.log(firstLoad(10)); //true
console.log(firstLoad(10)); //false
console.log(firstLoad(20)); //true
```
