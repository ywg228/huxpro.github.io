---
layout:     post
title:      ES6入门
subtitle:   ECMAScript 6
date:       2017-08-4
author:     Ywg
header-img: img/home-bg-o.jpg
catalog:    true
tags: JavaScript 
---

## 前言

## let变量
- 用let声明的变量只在花括号包裹的块中有用，即作用域只在块中，外部访问不到
``` 
for (let i = 0; i < 10; i++) {
}
console.log(i); // ReferenceError: i is not defined
``` 
- 注意：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。它们不在同一个作用域，有各自单独的作用域。
``` 
for (let i = 0; i < 10; i++) {
   var let i = 666;
   console.log(i); //输出10个666
} 
``` 
#### 不存在变量声明
let在声明前不能被使用，所以在使用前一定要先声明。
``` 
console.log(i); //ReferenceError
let i = 10;

console.log(j); //undefined
var j = 2;
``` 

#### 暂时死区
- ES6中会对let声明的变量形成一个块级作用域，只在花括号包裹的块中有效，外部不能访问。
- 使用let声明变量之前，该变量都是不可用的，这称为“暂时性死区”。（temporal dead zone，简称 TDZ）。
- 使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。
``` 
if (true) {
  // TDZ开始
  i = 10; // ReferenceError
  console.log(i); // ReferenceError

  let i; // TDZ结束
  console.log(i); // undefined

  i = 20;
  console.log(i); // 20
}
``` 
- ES6 规定暂时性死区和let、const语句不存在变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

#### 不允许重复声明 
let不允许在同一作用域内，重复声明同一个变量。
``` 
let i = 10;

let i = 20; // 报错
``` 
- 不能在函数内部重新声明参数。它们都在同一作用域
``` 
function func(arg) {
  let arg; // 报错
}
``` 

## 块级作用域
- ES5 只有全局作用域和函数作用域，没有块级作用域。
#### 为什么需要块级作用域？ 
块级作用域解决了ES5中常见的两个问题。 <br>
第一种情况：内层变量可能会覆盖外层变量。
```
 var i = 10;
 function func() {
   console.log(i);
   if(false) {
      var i = 20;  
   }
 }
 func(); //undefined
 ```
第二种情况：用来计数的循环变量泄露为全局变量 
 ```
for(var i = 0; i < 10; i++) {
  
}
console.log(i); //10
 ```
#### let为 JavaScript 新增了块级作用域
 ```
let i = 10;
if (true) {
  let i = 20;
}
console.log(i); // 10
 ```
#### 立即执行函数没有必要了
 ```
// IIFE 写法
(function () {
  var i = 10;
}());

// 块级作用域写法
{
  var i = 10;
}
 ```
 
 #### 允许在块级作用域中声明函数
